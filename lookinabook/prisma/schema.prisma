// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement()) // Unique identifier
  username  String?   @unique                      // Unique username
  email     String   @unique                      // Unique email
  password  String                                // Password (stored in encrypted form)
  role      Role     @default(USER)               // User role
  createdAt DateTime @default(now())              // Creation date
  updatedAt DateTime @updatedAt                   // Auto-updated modification date
  points      Int       @default(0)                 // User points
  lastActive  DateTime?                             // Last active date (optional)
  bio       String?
  avatar      String?

  // Relations
  books       Book[] 
  comments    Comment[] // User comments remain
  likes       Like[]    // Likes remain
  posts       Post[] // User
  notifications Notification[] // User
  subscriptionsAsSubscriber Subscription[] @relation("SubscriptionsAsSubscriber") // User subscriptions are deleted
  subscriptionsAsSubscribedTo Subscription[] @relation("SubscriptionsAsSubscribedTo") // Subscriptions to the user are deleted
  messagesSent     Message[] @relation("SentMessages") 
  messagesReceived Message[] @relation("ReceivedMessages")
  pointsLogs  PointsLog[]
}

enum Role {
  USER       // Regular user
  ADMIN      // Administrator
}

model Book {
  id          Int      @id @default(autoincrement()) // Unique book identifier
  title       String                                 // Book title
  annotation  String?                                // Annotation (optional)
  slug        String   @unique                      // Unique slug for the book
  cover       String?                               // URL of the book cover
  createdAt   DateTime @default(now())              // Creation date
  updatedAt   DateTime @updatedAt                   // Modification date

  // Relations
  authorId    Int                                   // Author ID
  author      User     @relation(fields: [authorId], references: [id], onDelete: Cascade) // Relation with the author
  chapters    Chapter[]
  comments    Comment[]
  likes       Like[]
}

model Chapter {
  id         Int      @id @default(autoincrement()) // Unique chapter identifier
  title      String                                // Chapter title
  content    String                                // Chapter content
  createdAt  DateTime @default(now())             // Creation date
  updatedAt  DateTime @updatedAt                  // Modification date

  // Relation with the book
  bookId     Int                                 // Book ID
  book       Book     @relation(fields: [bookId], references: [id], onDelete: Cascade) // Relation with the book

  comments    Comment[]
}

model Comment {
  id         Int      @id @default(autoincrement()) // Unique comment identifier
  content    String                                // Comment content
  createdAt  DateTime @default(now())              // Creation date
  updatedAt  DateTime @updatedAt                   // Modification date

  // Relations
  authorId   Int?                                   // Author ID of the comment
  author     User?     @relation(fields: [authorId], references: [id], onDelete: SetNull) // Relation with the author

  // Possible comment targets
  bookId     Int?                                  // Book ID (if the comment is on a book)
  book       Book?    @relation(fields: [bookId], references: [id], onDelete: Cascade) // Relation with the book

  chapterId  Int?                                  // Chapter ID (if the comment is on a chapter)
  chapter    Chapter? @relation(fields: [chapterId], references: [id], onDelete: Cascade) // Relation with the chapter

  postId     Int?                                  // Post ID (if the comment is on a post)
  post       Post?    @relation(fields: [postId], references: [id], onDelete: Cascade) // Relation with the post
}

model Post {
  id         Int      @id @default(autoincrement())
  title      String
  content    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  image      String?

  authorId   Int
  author     User     @relation(fields: [authorId], references: [id], onDelete: Cascade) // Post author

  comments   Comment[]  // Relation with comments
  likes       Like[]
}

model Like {
  id        Int      @id @default(autoincrement())
  type      LikeType // Type of like: COVER, PLOT, WRITING_STYLE, POST
  createdAt DateTime @default(now()) // Creation date
  userId    Int      // User ID who liked
  user      User     @relation(fields: [userId], references: [id]) // Relation with the user

  // Relation with the book (optional)
  bookId    Int?     // Book ID
  book      Book?    @relation(fields: [bookId], references: [id], onDelete: Cascade)

  // Relation with the post (optional)
  postId    Int?     // Post ID
  post      Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([type, userId, bookId], map: "unique_like_book") // Unique like for a book
  @@unique([userId, postId], map: "unique_like_post")       // Unique like for a post
}

enum LikeType {
  COVER          // Like for the cover
  PLOT           // Like for the plot
  WRITING_STYLE  // Like for the writing style
  POST           // Like for the post
}

model Subscription {
  id             Int      @id @default(autoincrement()) // Unique subscription identifier
  createdAt      DateTime @default(now())              // Subscription creation date

  // Subscriber
  subscriberId   Int     // Subscriber ID
  subscriber     User    @relation("SubscriptionsAsSubscriber", fields: [subscriberId], references: [id], onDelete: Cascade) // Relation with the subscriber

  // Subscribed to
  subscribedToId Int     // Subscribed to user ID
  subscribedTo   User    @relation("SubscriptionsAsSubscribedTo", fields: [subscribedToId], references: [id], onDelete: Cascade) // Relation with the subscribed user

  @@unique([subscriberId, subscribedToId]) // Unique subscription
}

model Message {
  id          Int      @id @default(autoincrement()) // Unique message identifier
  text        String   // Message text
  createdAt   DateTime @default(now())               // Message creation date
  senderId    Int?     // Sender ID
  recipientId Int?     // Recipient ID
  isRead      Boolean @default(false)                  // Message read status (default: false)

  // Message sender
  sender      User?    @relation("SentMessages", fields: [senderId], references: [id], onDelete: SetNull) // Relation with the sender

  // Message recipient
  recipient   User?    @relation("ReceivedMessages", fields: [recipientId], references: [id], onDelete: SetNull) // Relation with the recipient

  // Message belongs to both users
  @@index([senderId, recipientId])  // Index for quick search of messages between users
}

enum NotificationType {
  MESSAGE
  SUBSCRIPTION
  LIKE
  COMMENT
  RECOMMENDATION
  POINT_CHANGE
  CUSTOM
}

model Notification {
  id          Int               @id @default(autoincrement())
  type        NotificationType                              // Notification type
  content     String?                                      // Notification text
  isRead      Boolean          @default(false)            // Read status
  userId      Int                                          // User ID the notification is for
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt   DateTime         @default(now())
}

model PointsLog {
  id        Int      @id @default(autoincrement())
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  change    Int                                     // Change in points (can be negative)
  reason    String                                  // Reason for the point change
  createdAt DateTime @default(now())               // Date of the change
}


